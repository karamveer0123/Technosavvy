var option, dom = document.getElementById("candlestickgrphindex1"), myChart = echarts.init(dom, null, { renderer: "canvas", useDirtyRect: !1 }), app = {}, ROOT_PATH = "/js/Graph/src/candel.json", getList2 = localStorage.getItem("switchColor"); let retArray2 = JSON.parse(getList2); if (retArray2) var upColor = retArray2[0].bsred, downColor = retArray2[0].secondColor; else upColor = "#076641", downColor = "#f6465d"; function displayUpdate() { var e = process(); MAprocess(e), e.dataZoom = myChart.getOption().dataZoom, myChart.setOption(e, !0) } function MAprocess(e) { MA.forEach((function (t) { e.series.push(getMA(t.days)) })) } function createOrupdateBAR(e, t) { var a = (new moment).unix(); if ((null != t.tradePrice && null != t.tradePrice || (t = t.trade), liveBARS.length > 0) && (o = liveBARS[liveBARS.length - 1]).time >= e) return o.x.close = t.tradePrice, o.x.low > t.tradePrice && (o.x.low = t.tradePrice), o.x.high < t.tradePrice && (o.x.high = t.tradePrice), null != o.z.volumn | null != o.z.volumn ? o.z.volumn += t.tradeVolumn : o.z.volumn = t.tradeVolumn, liveBARS[liveBARS - 1] = o, o; var o = buildData(dataBARS.length + liveBARS.length - 1, null), n = $("#barTime option:selected").attr("data-du"), r = 0; if (dataBARS.length > 1) { if (n = dataBARS[1].time - dataBARS[0].time, liveBARS.length > 0) { for (var i = (l = liveBARS[liveBARS.length - 1].time) + n; i < a;)i = l + n * ++r; o.time = i } else { var l; for (i = (l = dataBARS[dataBARS.length - 1].time) + n; i < a;)i = l + n * ++r; o.time = i } var s = new Date(0); s.setUTCSeconds(o.time), o.date = moment.utc(s).local(), o.x.open = t.tradePrice, o.x.close = t.tradePrice, o.x.high = t.tradePrice, o.x.low = t.tradePrice, o.z.volumn = t.tradeVolumn } return o } var dataBARS = [], liveBARS = []; function buildBars(e) { dataBARS.splice(0, dataBARS.length); for (let t = 0; t < e.length; t++)dataBARS.push(buildData(t, e[t])) } function buildData(e, t) { if (null != t) { var a = new Date(0); a.setUTCSeconds(t.time); var o = moment.utc(a).local(); return { i: e, time: t.time, date: o, x: { open: t.open, close: t.close, low: t.low, high: t.high }, y: o, z: { i: e, volumn: t.volumn, status: t.status } } } return { i: e, time: 0, date: new moment, x: { open: 0, close: 0, low: 0, high: 0 }, y: Date(0), z: { i: e, volumn: 0, status: 0 } } } function get_yAxis() { var e = [], t = -1; for (let n = 0; n < dataBARS.length; n++) { ("12:00" == (o = (a = dataBARS[n]).date.format("hh:mm")) || "00:00" == o) && n - t > 10 ? (t = n, e.push(a.date.format("DD-MMM hh:mm"))) : e.push(a.date.format("hh:mm")) } t = -1; for (let n = 0; n < liveBARS.length; n++) { var a, o; ("12:00" == (o = (a = liveBARS[n]).date.format("hh:mm")) || "00:00" == o) && n - t > 10 ? (t = n, e.push(a.date.format("DD-MMM hh:mm"))) : e.push(a.date.format("hh:mm")) } return e } function get_xAxis() { var e = []; for (let o = 0; o < dataBARS.length; o++) { var t = dataBARS[o].x; (a = []).push(t.open), a.push(t.close), a.push(t.low), a.push(t.high), e.push(a) } for (let o = 0; o < liveBARS.length; o++) { var a; t = liveBARS[o].x; (a = []).push(t.open), a.push(t.close), a.push(t.low), a.push(t.high), e.push(a) } return e } function get_zAxis() { var e = []; for (let o = 0; o < dataBARS.length; o++) { var t = (a = dataBARS[o]).z; e.push([t.i, t.volumn, a.x.open > a.x.close ? 0 : 1]) } e.length; for (let o = 0; o < liveBARS.length; o++) { var a; t = (a = liveBARS[o]).z; e.push([t.i, t.volumn, a.x.open > a.x.close ? 0 : 1]) } return e } function doLoadMoreLeftBars() { var e = "getbarsbefore?mcode=" + __mCode + "&pulse=" + $("#barTime").val() + "&before=" + dataBARS[0].time; $.get(MktAPI + e, (function (e) { var t = []; for (let a = 0; a < e.length; a++)t.push(buildData(a, e[a])); t.length > 0 ? (buildBars($.merge(t, dataBARS)), displayUpdate(), console.log("--\x3eLoad more on Left")) : console.log("--\x3eNO more Data to Load on Left") })) } function getTime(e) { return null == e || null == e ? (new moment).unix() : null == e.timeStamp || null == e.timeStamp ? e.trade.timeStamp : e.timeStamp } let plastStamp = 0, lastStamp = 0, NextStamp = 0; function offMAData(e) { MA.forEach((function (t, a) { t.name == e && MA.splice(a, 1) })), option.series.forEach((function (t, a) { t.name == e && option.series.splice(a, 1) })) } function onMAData(e, t) { var a = !1; option.series.forEach((function (t) { t == e && (a = !0) })), a || option.series.push(getMA(t)) } function calculateMA(e) { for (var t = [], a = 0, o = dataBARS.length; a < o; a++)if (a < e) t.push("-"); else { for (var n = 0, r = 0; r < e; r++)n += dataBARS[a - r].x.close; t.push(+(n / e).toFixed(3)) } return t } function getMA(e) { return { name: "MA" + e.toString(), type: "line", data: calculateMA(e), smooth: !0, showSymbol: !0, lineStyle: { opacity: 2.5 } } } var liveOn = !0; function mainData(e) { e = "getbars?mcode=" + __mCode + "&pulse=" + e, $.get(MktAPI + e, (function (e) { null != e && null != e ? (liveOn = !1, buildBars(e), liveBARS = [], option = process(), myChart.setOption(option), liveOn = !0) : console.log("Initial Bar Data Load Returns NULL") })) } function updateInfo(e) { if (dataBARS.length >= e) { if ($("#ud").html(dataBARS[e].date.format("DD-MMM hh:mm")), e > 0) { var t = dataBARS[e - 1].x.close, a = dataBARS[e].x.close, o = (a - t) / a * 100; $("#uch").html(GetPercentFormat(o, 2)), o >= 0 ? ($("#uch").addClass("green"), $("#uch").removeClass("red")) : ($("#uch").addClass("red"), $("#uch").removeClass("green")) } $("#uo").html(GetFormatedValAdjWithSep(dataBARS[e].x.open, __qf)), $("#uc").html(GetFormatedValAdjWithSep(dataBARS[e].x.close, __qf)), $("#uh").html(GetFormatedValAdjWithSep(dataBARS[e].x.high, __qf)), $("#ul").html(GetFormatedValAdjWithSep(dataBARS[e].x.low, __qf)); var n = '<div  class="chartdigt665"><span class="default-label-box">Volume:</span><span class="default-label-box purple">' + GetFormatedValAdjWithSep(dataBARS[e].z.volumn, __bf) + "</span>"; myChart.getOption().series.forEach((function (t) { null != t.name.match(/^ma/i) && (n += '<div class="chartdigt665"><span class="default-label-box">' + t.name + ':</span><span class="default-label-box">' + t.data[e] + "</span></div>"), n += "</div>" })), $("#ul2").html(n) } } function __CheckAndDisplay() { } function process() { var e = get_xAxis(), t = get_yAxis(), a = get_zAxis(); return opt = { animation: !1, legend: { show: !1 }, tooltip: { show: !0, trigger: "axis", axisPointer: { type: "cross" }, borderWidth: 1, borderColor: "#ccc", padding: 10, textStyle: { color: "#777", fontSize: "12" }, position: function (e, t, a, o, n) { const r = { top: -1e3 }; r[["left", "right"][+(e[0] < n.viewSize[0] / 2)]] = 30; try { updateInfo(t[0].data[0]) } catch (e) { } return r } }, axisPointer: { show: !0, link: [{ xAxisIndex: "all" }], label: { backgroundColor: "#777" } }, toolbox: { feature: { dataZoom: { show: !1, yAxisIndex: !1 }, brush: { show: !1, type: ["lineX", "clear"] } } }, brush: { xAxisIndex: "all", brushLink: "all", outOfBrush: { colorAlpha: .1 } }, visualMap: { show: !1, seriesIndex: 5, dimension: 2, pieces: [{ value: 0, color: downColor }, { value: 1, color: upColor }] }, grid: [{ left: "10%", right: "8%", top: "2%", height: "85%" }, { left: "10%", right: "8%", top: "90%", height: "10%" }], xAxis: [{ type: "category", data: t, boundaryGap: !1, axisLine: { onZero: !1 }, splitLine: { show: !0, lineStyle: { color: "#0c03094a" } }, min: "dataMin", max: "dataMax", axisPointer: { z: 100 } }, { type: "category", gridIndex: 1, data: t, boundaryGap: !1, axisLine: { onZero: !1 }, axisTick: { show: !1 }, splitLine: { show: !0, lineStyle: { color: "#0c03094a" } }, axisLabel: { show: !0 }, min: "dataMin", max: "dataMax" }], yAxis: [{ scale: !0, position: "right", splitArea: { show: !1 }, splitLine: { show: !0, lineStyle: { color: "#0c03094a" } } }, { scale: !0, gridIndex: 1, scale: !0, position: "right", splitNumber: 2, axisLabel: { show: !0 }, axisLine: { show: !0 }, axisTick: { show: !0 }, splitLine: { show: !0, lineStyle: { color: "#0c03094a" } } }], dataZoom: [{ type: "inside", xAxisIndex: [0, 1], start: 75, end: 100 }], series: [{ name: __mCode, type: "candlestick", data: e, itemStyle: { color: upColor, color0: downColor, borderColor: void 0, borderColor0: void 0 }, tooltip: { formatter: function (e) { return ["Date: " + (e = e[0]).name + '<hr size=1 style="margin: 3px 0">', "Open: " + e.data[0] + "<br/>", "Close: " + e.data[1] + "<br/>", "Lowest: " + e.data[2] + "<br/>", "Highest: " + e.data[3] + "<br/>"].join("") }, className: "d-none" } }, { name: "Volume", type: "bar", xAxisIndex: 1, yAxisIndex: 1, data: a }] } } var MA = [], shouldLoad = !1, pLeft = 0; function subscribe() { $("input:checkbox").change((function () { var e = $(this).attr("data-ma"); if (null != e) if ($(this).is(":checked")) { var t = $(this).attr("data-days"); onMAData(e, t), MA.push({ name: e, days: t }), myChart.setOption(option) } else offMAData(e), myChart.setOption(option, { replaceMerge: ["xAxis", "yAxis", "series"] }) })); var e = $("#barTime"); e.children().remove(), e.append("<option>", BarOps()), $("#barTime option")[1].selected = !0, mainData($("#barTime").val()), e.on("change", (function (e) { SwitchBARS($(this).val(), $("#barTime option:selected").attr("data-du")) })), myChart.on("mousemove", (function (e) { updateInfo(e.data[0]) })), myChart.on("dataZoom", (function (e) { (e = e.batch[0]).start < pLeft ? shouldLoad = !0 : e.start > pLeft && (shouldLoad = !1), shouldLoad && 0 == e.start && doLoadMoreLeftBars(), pLeft = e.start })) } var BarOp = []; function BarOps() { BarOp.push({ name: "1min", duration: 60 }), BarOp.push({ name: "2min", duration: 120 }), BarOp.push({ name: "15min", duration: 900 }), BarOp.push({ name: "30min", duration: 1800 }), BarOp.push({ name: "1hrs", duration: 3600 }), BarOp.push({ name: "4hrs", duration: 1440 }), BarOp.push({ name: "6hrs", duration: 21600 }), BarOp.push({ name: "8hrs", duration: 28800 }), BarOp.push({ name: "1day", duration: 86400 }), BarOp.push({ name: "3day", duration: 259200 }), BarOp.push({ name: "7day", duration: 604800 }); var e = "", t = !1; return BarOp.forEach((a => { 0 == t ? (e += '<option selected="true" data-du="' + a.duration + '" value=' + a.name + ">" + a.name + "</option>", t = !0) : e += '<option data-du="' + a.duration + '" value=' + a.name + ">" + a.name + "</option>" })), e } function SwitchBARS(e, t) { mainData(e), Refresh(), console.log("BAR Changed to " + e + " " + t.toString()) } option && "object" == typeof option && myChart.setOption(option), window.addEventListener("resize", myChart.resize);